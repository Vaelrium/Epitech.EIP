Format du document
==================
Globalement très bien, la documentation utilisateur est un peu austère, mais adressée au monde Linux, Mac principalement (ou du moins c’est ce que vous faites ressentir dans votre UD), ce qui est moins choquant, ces communautés ayant plus l’habitude des documentations austères et simples dans leur format. Essayez de démarquer un peu plus votre en-tête à l’image du pied de page. Quand vous faites une insertion de commande terminal ou de code, utilisez des polices différentes, avec des bordures et un fond différent pour le paragraphe, utilisez la coloration syntaxique et évitez les copies d’écran. Attention, le résumé n'est pas un résumé mais une introduction. Le résumé synthétise le document, il faut reprendre le contenu clé du document et non pas l'introduire, vous avez essayé de le modifier, mais ce n’est toujours pas ça.

Documentation Utilisateur
=========================
Evitez 1 page pour une capture, ça fait très remplissage et désagréable à lire. Globalement le contenu est maintenant très correct. Il me manque toujours l’explication des règles et leur dictionnaire pour montrer quelles options comment faire. L’installation de chaque driver est bien, je mettrai les points d’attention beaucoup plus en évidence (comme bornés entre 2 lignes, avec un panneau attention et sur fond rouge ou orange clair). Essayez de trouver un mode rendu mon textuel et désagréable à présent, vu que vous avez une répétition par driver, une présentation avec un cartouche descriptif du driver pour donner plus de lisibilité au fil des drivers peut être intéressant. Le contenu commence à être complet, il y a toujours des petits trous (des retours également faits en UD2), et le format est à améliorer.

Documentation Technique
=======================
Toute la première partie est plutôt correcte et intéressante, je la condenserai et réorganiserai un peu, car elle fait morceaux raccrochés les uns aux autres. Le contenu est lui en revanche tout à fait correct, avec la description de la gestion de configuration, des normes, des tests, et comment faire le setup d’un environnement de dev. Il me manque dans cette première partie une présentation globale d’Onitu (fonctionnellement) via un petit schéma très utilisateur final (un dessin d’ordinateur, et une représentation de synchronisation vers les différents services que vous supportez avec leur logo, pour bien imager le but de votre projet). Le premier schéma est un peu complexe pour un premier schéma, il nécessite de comprendre déjà la logique globale du projet pour voir les différents composants et leur rôle car cela n’a pas été amené avant, mais quand j’y reviens après lecture du document, c’est intéressant, et plutôt bien illustré. Ne revenez pas sur la gestion de configuration, regroupez ces parties (cf mon premier commentaire sur l’aspect raccroc des différentes parties). La partie suivant n’est pas adaptée. Il faut que vous passiez plus par de la modélisation, du diagramme par thème / groupes de fonctionnalités qu’une explication textuelle aussi longue qui n’apporte pas de valeur. Un diagramme objet, de classe découpé en grands packages du projet doit être le support principal des explications. Vous devez illustrer également beaucoup plus les API ou autres interfaces qui doivent être utilisées pour les différents modules afin de comprendre la structure de contribution. La partie test, devrait être extraite et beaucoup mieux traitées à la fin. J’attendrai des diagrammes de séquence pour expliquer la complexité du processus de download, upload, sync entre les différents composants (file système, serveur, drivers, services concernés). Ici vous traitez quasiment tous les fichiers de façon beaucoup trop partielle. Votre document ressemble plus à une documentation pour une communauté qui voudrait ajouter un driver et vous n’ouvrez donc pas le capot de votre projet, alors que c’est son réel objet. Vous devez faire le plan de ce que vous avez implémenté avec une approche de haut niveau vers le détail, et logique (conceptuelle) vers physique (implémentation). Le document est destiné à un développeur qui rejoindrait le projet (et non un développeur de la communauté), il faut donc décrire rapidement quel est le projet, puis avec une vue fonctionnelle très rapide (habituellement exprimée par des use case pour rendre la description en diagrammes, un schéma vue utilisateur), vous devez proposer un schéma d'architecture globale (quelles grandes solutions et usages, composants). Puis vous présentez une vue logique du projet, vue qui reprend les composants avec une vue de haut niveau et les entités métiers (qui pourront représenter en fait plusieurs objets ou classes au final). Vous devez présenter les différentes technologies que vous utilisez (brièvement) pour que l'on cible les composants internes et externes au projet. Vous allez ensuite vers une vue physique du projet en composants et classes, et en expliquant leur fondement et ce qu'ils font (pas besoin de décrire toutes les propriétés des objets, déjà les méthodes principales et interactions, avec les interfaces suffisent), pour éventuellement finir sur la sauvegarde de l'état des objets (base de données ou autre). Vous devez également présenter l'environnement de développement et sa configuration, ainsi que la gestion de configuration et son utilisation (stratégie pour les branches et les releases, s'il y a des tests types pour que du code soit éligible à une release, une éventuelle intégration continue). Vous devez enfin présenter la norme du code et les bonnes pratiques que vous appliquez au projet.

Commentaires publiques
======================
Un gros effort a été fait sur la documentation utilisateur et technique. Le contenu de la documentation utilisateur est plutôt bien, il faut améliorer le format et continuer à faire vivre en ajoutant les points manquants. La construction de la documentation technique est intéressante dans l’approche mais avec encore trop de points non couverts ou trop peu détaillés. Il faut reprendre ce document en réorganisant le contenu à valeur ajoutée déjà présent et en complétant avec ce qui est manquant.